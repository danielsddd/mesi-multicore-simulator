================================================================================
              MULTI-CORE MESI SIMULATOR - COMPREHENSIVE SPECIFICATION
              Tel Aviv University - Computer Architecture (0512.4461)
================================================================================

================================================================================
SECTION 1: ARCHITECTURE OVERVIEW
================================================================================

The simulator implements:
- 4 cores running in PARALLEL
- Each core is PIPELINED (5 stages)
- Each core has PRIVATE instruction memory (SRAM)
- Each core has PRIVATE data cache
- All cores connected via BUS with MESI coherency protocol
- SHARED main memory

Architecture Diagram:
    Core 0          Core 1          Core 2          Core 3
    IMEM 0          IMEM 1          IMEM 2          IMEM 3
    Cache 0         Cache 1         Cache 2         Cache 3
       |               |               |               |
       +---------------+---------------+---------------+
                           |
                    BUS (MESI Protocol)
                           |
                     Main Memory

================================================================================
SECTION 2: SPECIFIC IMPLEMENTATION DETAILS (DIFFERS FROM STANDARD MIPS/MESI)
================================================================================

CRITICAL DIFFERENCES FROM STANDARD MIPS:
-----------------------------------------
1. NO BYPASSING/FORWARDING - Data hazards resolved by STALL only
2. NO half clock cycles for register file access - uses FULL clock cycle
3. Branch resolution happens in DECODE stage (not Execute)
4. Delay slot IS used (instruction after branch ALWAYS executes)
5. Register 1 ($imm) is special - contains sign-extended immediate, updated each decode
6. Register 0 is hardwired to 0, writes are ignored
7. PC is 10 bits (not 32), increments by 1 (not 4)

CRITICAL DIFFERENCES FROM STANDARD MESI:
-----------------------------------------
1. Bus transaction takes ONE cycle to initiate
2. Memory response is 16 cycles AFTER receiving read command for first word
3. Remaining 7 words come in consecutive cycles (total 8 words per block)
4. Round-robin arbitration - last granted core has LOWEST priority next time
5. Bus cannot be granted while previous BusRd/BusRdX not completed by Flush
6. Main memory has origid = 4 (cores are 0-3)

================================================================================
SECTION 3: DETAILED COMPONENT SPECIFICATIONS
================================================================================

-----------------------------------------------------------------------------
3.1 REGISTERS (PER CORE)
-----------------------------------------------------------------------------
- 16 registers: R0 to R15
- Width: 32 bits each
- R0: Always 0, writes are ignored
- R1 ($imm): Special register
  * Cannot be written to by instructions
  * Contains sign-extended immediate from current instruction
  * Updated during DECODE stage for every instruction
- R2-R15: General purpose registers
- Register file supports: 3 reads + 1 write per cycle
- IMPORTANT: Data written in cycle N available for read in cycle N+1

-----------------------------------------------------------------------------
3.2 INSTRUCTION MEMORY (PER CORE)
-----------------------------------------------------------------------------
- Type: Private SRAM
- Width: 32 bits
- Depth: 1024 lines (addresses 0-1023)
- PC register: 10 bits
- Access time: 1 clock cycle
- Sequential instructions: PC increments by 1

-----------------------------------------------------------------------------
3.3 PIPELINE (PER CORE)
-----------------------------------------------------------------------------
5 stages:
1. FETCH (IF)    - Read instruction from IMEM
2. DECODE (ID)   - Decode instruction, read registers, resolve branches
3. EXECUTE (EX)  - ALU operations
4. MEMORY (MEM)  - Memory access (load/store via cache)
5. WRITE BACK (WB) - Write result to register file

Pipeline Features:
- Delay slot: YES (instruction after branch always executes)
- Bypassing/Forwarding: NO
- Data hazard resolution: STALL in DECODE stage
- Cache miss handling: STALL in MEM stage
- Branch resolution: DECODE stage

STALL BEHAVIOR:
- Data hazard stall: Instruction waits in DECODE, FETCH also stalls
- Memory stall: Instruction waits in MEM, all earlier stages stall
- Later stages (e.g., WB) continue if they have valid instructions

-----------------------------------------------------------------------------
3.4 DATA CACHE (PER CORE)
-----------------------------------------------------------------------------
Structure:
- Mapping: Direct mapped
- Total size: 512 words
- Block size: 8 words
- Number of blocks: 512/8 = 64 blocks
- Hit time: 1 clock cycle
- Write policy: Write-back, Write-allocate

Address breakdown (21-bit word address):
- Bits [2:0]   = Block offset (3 bits for 8 words)
- Bits [8:3]   = Index/Set (6 bits for 64 sets)
- Bits [20:9]  = Tag (12 bits)

DSRAM (Data SRAM):
- Width: 32 bits
- Depth: 512 words
- Contains: Actual cached data
- Initialized to: 0

TSRAM (Tag SRAM):
- Depth: 64 lines (one per cache block)
- Per line format:
  * Bits [11:0]  = Tag (12 bits)
  * Bits [13:12] = MESI state (2 bits)
- Initialized to: 0 (all Invalid state)

MESI States (as defined in assignment):
- 0 = Invalid
- 1 = Shared
- 2 = Exclusive
- 3 = Modified

-----------------------------------------------------------------------------
3.5 MAIN MEMORY
-----------------------------------------------------------------------------
- Address space: 21 bits
- Size: 2^21 = 2,097,152 words
- Word width: 32 bits
- Access: Word-only (no byte access)
- Latency for read: 16 cycles for first word, then consecutive

-----------------------------------------------------------------------------
3.6 BUS SIGNALS
-----------------------------------------------------------------------------
Signal          Width   Values/Description
------          -----   ------------------
bus_origid      3 bits  0: Core 0
                        1: Core 1
                        2: Core 2
                        3: Core 3
                        4: Main Memory

bus_cmd         2 bits  0: No command
                        1: BusRd (read for load, shared ok)
                        2: BusRdX (read for store, exclusive)
                        3: Flush (data response)

bus_addr        21 bits Word address

bus_data        32 bits Data word

bus_shared      1 bit   Set to 1 by snooping cache if it has the block
                        Used to determine Exclusive vs Shared on BusRd

================================================================================
SECTION 4: INSTRUCTION SET ARCHITECTURE (ISA)
================================================================================

-----------------------------------------------------------------------------
4.1 INSTRUCTION FORMAT (32 bits)
-----------------------------------------------------------------------------
  31      24 23    20 19    16 15    12 11              0
 +----------+--------+--------+--------+------------------+
 |  Opcode  |   rd   |   rs   |   rt   |    immediate     |
 +----------+--------+--------+--------+------------------+
     8 bits   4 bits   4 bits   4 bits      12 bits

- Opcode: bits [31:24] (8 bits)
- rd: bits [23:20] (4 bits) - destination register
- rs: bits [19:16] (4 bits) - source register 1
- rt: bits [15:12] (4 bits) - source register 2
- immediate: bits [11:0] (12 bits, sign-extended to 32 bits)

-----------------------------------------------------------------------------
4.2 ASSEMBLY SYNTAX
-----------------------------------------------------------------------------
General format:
    opcode $rd, $rs, $rt, immediate

Register names:
- $r0 through $r15, or $zero, $imm (for R0 and R1 respectively)
- R1 ($imm) always contains sign-extended immediate value

Examples:
    add $r2, $r2, $imm, 1        # R2 = R2 + R1 (where R1=1)
    lw $r3, $zero, $imm, 15     # R3 = MEM[R0 + R1] = MEM[15]
    blt $zero, $r2, $imm, 100   # if (R2 < R1) PC = R0[9:0] (branch target = 0)

-----------------------------------------------------------------------------
4.3 OPCODE TABLE
-----------------------------------------------------------------------------
Op  Hex   Name    Operation                               Notes
--  ---   ----    ---------                               -----
0   0x00  add     R[rd] = R[rs] + R[rt]
1   0x01  sub     R[rd] = R[rs] - R[rt]
2   0x02  and     R[rd] = R[rs] & R[rt]
3   0x03  or      R[rd] = R[rs] | R[rt]
4   0x04  xor     R[rd] = R[rs] ^ R[rt]
5   0x05  mul     R[rd] = R[rs] * R[rt]                   32-bit result
6   0x06  sll     R[rd] = R[rs] << R[rt]                  Logical left
7   0x07  sra     R[rd] = R[rs] >> R[rt]                  Arithmetic right
8   0x08  srl     R[rd] = R[rs] >> R[rt]                  Logical right
9   0x09  beq     if (R[rs] == R[rt]) PC = R[rd][9:0]     Branch equal
10  0x0A  bne     if (R[rs] != R[rt]) PC = R[rd][9:0]     Branch not equal
11  0x0B  blt     if (R[rs] < R[rt]) PC = R[rd][9:0]      Branch less (SIGNED)
12  0x0C  bgt     if (R[rs] > R[rt]) PC = R[rd][9:0]      Branch greater (SIGNED)
13  0x0D  ble     if (R[rs] <= R[rt]) PC = R[rd][9:0]     Branch less/equal (SIGNED)
14  0x0E  bge     if (R[rs] >= R[rt]) PC = R[rd][9:0]     Branch greater/equal (SIGNED)
15  0x0F  jal     R[15] = PC+1, PC = R[rd][9:0]           Jump and link
16  0x10  lw      R[rd] = MEM[R[rs] + R[rt]]              Load word
17  0x11  sw      MEM[R[rs] + R[rt]] = R[rd]              Store word
20  0x14  halt    Halt this core                          Core stops execution

IMPORTANT NOTES:
- Branch target comes from R[rd], only lower 10 bits used
- Comparison in branches is SIGNED (for blt, bgt, ble, bge)
- jal saves return address (PC+1) in R[15] specifically
- Address calculation for lw/sw: R[rs] + R[rt] (not rs + immediate!)

-----------------------------------------------------------------------------
4.4 VERIFIED ENCODING EXAMPLES (from example files)
-----------------------------------------------------------------------------
Assembly:                           Hex:        Breakdown:
add $r2, $r2, $imm, 1               00221001    op=00 rd=2 rs=2 rt=1 imm=001
add $r3, $r3, $imm, 1               00331001    op=00 rd=3 rs=3 rt=1 imm=001
blt $zero, $r2, $imm, 100           0B021064    op=0B rd=0 rs=2 rt=1 imm=064
blt $zero, $r3, $imm, 100           0B031064    op=0B rd=0 rs=3 rt=1 imm=064
blt $zero, $r2, $imm, 200           0B0210C8    op=0B rd=0 rs=2 rt=1 imm=0C8
lw $r3, $zero, $imm, 15             1030100F    op=10 rd=3 rs=0 rt=1 imm=00F
lw $r2, $zero, $imm, 17             10201011    op=10 rd=2 rs=0 rt=1 imm=011
sw $r2, $zero, $imm, 17             11201011    op=11 rd=2 rs=0 rt=1 imm=011
halt $zero, $zero, $zero, 0         14000000    op=14 rd=0 rs=0 rt=0 imm=000

================================================================================
SECTION 5: BUS PROTOCOL BEHAVIOR
================================================================================

-----------------------------------------------------------------------------
5.1 ARBITRATION
-----------------------------------------------------------------------------
- Method: Round-Robin
- Rule: Last core that received bus access has LOWEST priority next time
- Initial state: Core 3 is considered "last granted" (so Core 0 has highest priority initially)
- Condition: Bus must not be busy with ongoing transaction
- Condition: Previous BusRd/BusRdX must be completed by Flush before new grant

-----------------------------------------------------------------------------
5.2 BusRd TRANSACTION (Read for Load - Cache Miss)
-----------------------------------------------------------------------------
1. Core issues BusRd with address on bus, sets bus_shared = 0
2. All other caches snoop:
   - If any cache has the block, it sets bus_shared = 1
   - If a cache has block in Modified state:
     * That cache responds with Flush (instead of main memory)
     * Main memory updates in parallel
3. If no cache has Modified copy, main memory responds
4. Response: First word after 16 cycles, remaining 7 words in consecutive cycles
5. Requesting cache sets state to:
   - Exclusive if bus_shared = 0
   - Shared if bus_shared = 1

-----------------------------------------------------------------------------
5.3 BusRdX TRANSACTION (Read for Store - Cache Miss or Upgrade)
-----------------------------------------------------------------------------
1. Core issues BusRdX with address on bus
2. All other caches:
   - Invalidate their copy of the block (set to Invalid)
   - If Modified, respond with Flush first
3. Response same as BusRd
4. Requesting cache sets state to: Modified (will write)

Note: BusRdX is also used when cache has Shared state and wants to write
(needs exclusive access).

-----------------------------------------------------------------------------
5.4 FLUSH TRANSACTION
-----------------------------------------------------------------------------
- Used to send data on bus
- Originator can be: Core (if it had Modified) or Main Memory
- Sends 8 words in 8 consecutive cycles
- First word at cycle N, last word at cycle N+7
- When core flushes, main memory updates simultaneously

-----------------------------------------------------------------------------
5.5 SNOOPING BEHAVIOR
-----------------------------------------------------------------------------
Each cache must snoop every bus transaction and update its state:

On BusRd from another core:
- If Invalid: Do nothing
- If Shared: Stay Shared, set bus_shared = 1
- If Exclusive: Transition to Shared, set bus_shared = 1
- If Modified: Respond with Flush, transition to Shared, set bus_shared = 1

On BusRdX from another core:
- If Invalid: Do nothing
- If Shared: Transition to Invalid
- If Exclusive: Transition to Invalid
- If Modified: Respond with Flush, transition to Invalid

================================================================================
SECTION 6: PIPELINE HAZARD HANDLING
================================================================================

-----------------------------------------------------------------------------
6.1 DATA HAZARDS
-----------------------------------------------------------------------------
Detection: In DECODE stage, check if source registers match destination of:
- Instruction in EXECUTE stage
- Instruction in MEM stage
- Instruction in WB stage

Resolution: STALL the instruction in DECODE
- FETCH stage also stalls (stops fetching new instructions)
- Later stages continue normally (drain the pipeline)

Example:
  add R2, R3, R4  ; In EX, will write R2
  sub R5, R2, R6  ; In DECODE, needs R2 -> STALL

IMPORTANT: Even WB stage must be checked because write happens at end of WB,
and data is only available NEXT cycle for read.

Hazard Check (for instruction in DECODE needing register R as source):
  hazard = (R == dest_EX && dest_EX != 0 && has_dest_EX) ||
           (R == dest_MEM && dest_MEM != 0 && has_dest_MEM) ||
           (R == dest_WB && dest_WB != 0 && has_dest_WB)

Note: R0 is never a hazard (always 0), R1 is never a hazard (special register)

-----------------------------------------------------------------------------
6.2 MEMORY STALLS
-----------------------------------------------------------------------------
Cause: Cache miss in MEM stage

Resolution: STALL the instruction in MEM
- All earlier stages (FETCH, DECODE, EXECUTE) also stall
- Later stages (WB) continue if they have valid instructions

Duration: Until data arrives from bus transaction (typically 16+ cycles)

-----------------------------------------------------------------------------
6.3 BRANCH HANDLING
-----------------------------------------------------------------------------
- Branch resolution: DECODE stage
- Delay slot: One instruction after branch ALWAYS executes
- Branch target: From R[rd], lower 10 bits
- On taken branch: New PC loaded, but next instruction (delay slot) still fetched

Example with delay slot:
    PC=6:  blt $zero, $r2, $imm, 100   # if taken, PC = R[0][9:0] = 0
    PC=7:  add $r8, $r8, $imm, 1       # ALWAYS executes (delay slot)
    PC=8:  halt                         # executes only if branch not taken

================================================================================
SECTION 7: FILE FORMATS
================================================================================

-----------------------------------------------------------------------------
7.1 INPUT FILES
-----------------------------------------------------------------------------
imem0.txt, imem1.txt, imem2.txt, imem3.txt (Instruction Memory):
- Format: 8 hexadecimal digits per line (lowercase or uppercase)
- Starting address: 0
- Lines < 1024: Remaining memory is 0
- Example:
  00221001
  00331001
  0B021064
  14000000

memin.txt (Main Memory Initial):
- Format: 8 hexadecimal digits per line
- Starting address: 0
- Lines < 2^21: Remaining memory is 0
- Contains initial values for shared data

-----------------------------------------------------------------------------
7.2 OUTPUT FILES
-----------------------------------------------------------------------------
memout.txt (Main Memory Final):
- Same format as memin.txt
- Contains final memory state after simulation
- Should include all words up to the last non-zero word

regout0.txt - regout3.txt (Registers):
- Contains R2-R15 (14 registers) - NOT R0, NOT R1
- Format: 8 hexadecimal digits per line (lowercase)
- 14 lines total per file
- Example (from example_061225_win/regout0.txt):
  00000064
  00000064
  00000064
  ... (14 lines total)

core0trace.txt - core3trace.txt (Pipeline Trace):
- One line per cycle where at least one pipeline stage is active
- Cycles START from 0 (not 1)
- Format: CYCLE FETCH DECODE EXEC MEM WB R2 R3 ... R15
  * CYCLE: Decimal (starts at 0)
  * Pipeline stages: 3 hex digits (PC value) OR "---" if inactive
  * Registers: 8 hex digits (value at START of cycle)
  * Fields separated by single space
- Example:
  0 000 --- --- --- --- 00000000 00000000 00000000 ... (14 reg values)
  1 001 000 --- --- --- 00000000 00000000 00000000 ...
  2 002 001 000 --- --- 00000000 00000000 00000000 ...

bustrace.txt (Bus Trace):
- One line per cycle where bus_cmd != 0
- Format: CYCLE bus_origid bus_cmd bus_addr bus_data bus_shared
  * CYCLE: Decimal
  * bus_origid: 1 hex digit (0-3 for cores, 4 for main memory)
  * bus_cmd: 1 hex digit (1=BusRd, 2=BusRdX, 3=Flush)
  * bus_addr: 6 hex digits (21-bit address, leading zeros)
  * bus_data: 8 hex digits (32-bit data)
  * bus_shared: 1 hex digit (0 or 1)
- Example (from example_061225_win/bustrace.txt):
  5 2 1 00000F 00000000 0       # Cycle 5, Core 2, BusRd, addr 0x0F
  21 4 3 000008 00000000 0      # Cycle 21, Main Mem, Flush, addr 0x08

dsram0.txt - dsram3.txt (Data Cache SRAM):
- Format: 8 hex digits per line (lowercase)
- Exactly 512 lines total
- Contains cached data values

tsram0.txt - tsram3.txt (Tag Cache SRAM):
- Format: 8 hex digits per line (lowercase)
- Exactly 64 lines total
- Each line: (MESI << 12) | Tag
- Example values:
  * 00000000 = Invalid state, tag 0
  * 00001000 = Shared state (1 << 12), tag 0
  * 00002000 = Exclusive state (2 << 12), tag 0
  * 00003000 = Modified state (3 << 12), tag 0

stats0.txt - stats3.txt (Statistics):
- Format: "name X" where X is decimal integer
- Exactly 8 lines:
  cycles X        - Clock cycles until core halted and pipeline drained
  instructions X  - Instructions EXECUTED (not fetched)
  read_hit X      - Cache read hits
  write_hit X     - Cache write hits
  read_miss X     - Cache read misses
  write_miss X    - Cache write misses
  decode_stall X  - Cycles instruction stalled in decode stage
  mem_stall X     - Cycles instruction stalled in mem stage

Example (from example_061225_win/stats2.txt):
  cycles 1193
  instructions 508
  read_hit 100
  write_hit 101
  read_miss 2
  write_miss 1
  decode_stall 606
  mem_stall 75

================================================================================
SECTION 8: COMMAND LINE PARAMETERS
================================================================================

27 parameters in order:
1.  imem0.txt      (input)
2.  imem1.txt      (input)
3.  imem2.txt      (input)
4.  imem3.txt      (input)
5.  memin.txt      (input)
6.  memout.txt     (output)
7.  regout0.txt    (output)
8.  regout1.txt    (output)
9.  regout2.txt    (output)
10. regout3.txt    (output)
11. core0trace.txt (output)
12. core1trace.txt (output)
13. core2trace.txt (output)
14. core3trace.txt (output)
15. bustrace.txt   (output)
16. dsram0.txt     (output)
17. dsram1.txt     (output)
18. dsram2.txt     (output)
19. dsram3.txt     (output)
20. tsram0.txt     (output)
21. tsram1.txt     (output)
22. tsram2.txt     (output)
23. tsram3.txt     (output)
24. stats0.txt     (output)
25. stats1.txt     (output)
26. stats2.txt     (output)
27. stats3.txt     (output)

Default behavior: If no parameters, use above names from exe directory.

================================================================================
SECTION 9: KEY FORMULAS AND CALCULATIONS
================================================================================

-----------------------------------------------------------------------------
9.1 CACHE ADDRESS BREAKDOWN
-----------------------------------------------------------------------------
For 21-bit word address:
  block_offset = address[2:0]     (3 bits, values 0-7)
  index        = address[8:3]     (6 bits, values 0-63)
  tag          = address[20:9]    (12 bits)

DSRAM Address = (index * 8) + block_offset = address[8:0]  (9 bits)

TSRAM Address = index = address[8:3]  (6 bits)

TSRAM Entry = (MESI << 12) | tag

-----------------------------------------------------------------------------
9.2 SIGN EXTENSION (12-bit to 32-bit)
-----------------------------------------------------------------------------
if (immediate & 0x800)  // bit 11 is set (negative number)
    extended = immediate | 0xFFFFF000
else
    extended = immediate & 0x00000FFF

Example:
- 0x001 (1) -> 0x00000001 (positive)
- 0xFFF (-1 in 12-bit) -> 0xFFFFFFFF (-1 in 32-bit)
- 0x800 (-2048) -> 0xFFFFF800

-----------------------------------------------------------------------------
9.3 PIPELINE HAZARD CHECK
-----------------------------------------------------------------------------
For instruction in DECODE needing register R as source:
  hazard = (R == dest_EX && dest_EX != 0 && instruction_in_EX_writes_reg) ||
           (R == dest_MEM && dest_MEM != 0 && instruction_in_MEM_writes_reg) ||
           (R == dest_WB && dest_WB != 0 && instruction_in_WB_writes_reg)

Note: Don't check hazards for R0 (always 0) or R1 (always immediate).
Instructions that write registers: add, sub, and, or, xor, mul, sll, sra, srl, lw, jal

================================================================================
SECTION 10: SIMULATION END CONDITIONS
================================================================================

Simulation continues until ALL of these are true:
1. All 4 cores have executed a HALT instruction
2. All 4 pipelines are empty (no instructions in any stage)

A core that executes HALT:
- Stops fetching new instructions
- Allows pipeline to drain (existing instructions complete)
- Continues to participate in cache snooping

================================================================================
SECTION 11: DEBUGGING CHECKLIST
================================================================================

-----------------------------------------------------------------------------
11.1 COMMON PIPELINE BUGS
-----------------------------------------------------------------------------
[ ] R0 writes should be ignored
[ ] R1 should not be writable by instructions
[ ] R1 should update with sign-extended immediate every decode
[ ] Sign extension of 12-bit immediate to 32-bit (check negative numbers)
[ ] Branch target from R[rd] value, not rd field directly
[ ] Only lower 10 bits of branch target used
[ ] Delay slot instruction always executes
[ ] Data hazard detection includes WB stage
[ ] Stall in decode stops fetch too
[ ] Branch resolution in decode (not execute)
[ ] jal saves to R[15] specifically
[ ] Signed comparisons for blt, bgt, ble, bge

-----------------------------------------------------------------------------
11.2 COMMON CACHE BUGS
-----------------------------------------------------------------------------
[ ] Direct mapped indexing correct
[ ] Tag comparison correct
[ ] MESI state transitions correct
[ ] Write-back on eviction of Modified
[ ] Write-allocate on miss
[ ] Block offset handling (8 words per block)
[ ] TSRAM initialized to 0 (Invalid state)
[ ] BusRdX for write to Shared state (need to upgrade)

-----------------------------------------------------------------------------
11.3 COMMON BUS BUGS
-----------------------------------------------------------------------------
[ ] Round-robin priority (last granted = lowest priority)
[ ] bus_shared set by snoopers, not initiator
[ ] 16 cycle delay for main memory response
[ ] 8 consecutive cycles for block transfer
[ ] Modified cache responds instead of main memory
[ ] Main memory updates on Flush from Modified cache
[ ] No new transaction until previous completes

-----------------------------------------------------------------------------
11.4 COMMON OUTPUT BUGS
-----------------------------------------------------------------------------
[ ] Pipeline trace: cycle starts at 0
[ ] Pipeline trace: register values at START of cycle
[ ] Pipeline trace: "---" for inactive stages (three dashes)
[ ] Bus trace: only when bus_cmd != 0
[ ] Stats: instructions count (EXECUTED, not fetched)
[ ] Stats: decode_stall counts cycles, not occurrences
[ ] regout: only R2-R15, not R0 or R1 (14 lines)
[ ] Hex format: correct number of digits for each field
[ ] DSRAM: exactly 512 lines
[ ] TSRAM: exactly 64 lines

================================================================================
SECTION 12: EXAMPLE ANALYSIS
================================================================================

Based on example_061225_win:

Core 0 (imem0.asm): Simple loop with adds, no memory access
- stats0.txt: cycles=805, instructions=801, no cache activity, no stalls

Core 1 (imem1.asm): Similar to Core 0
- stats1.txt: cycles=705, instructions=501, decode_stall=200

Core 2 (imem2.asm): Read/write loop to memory addresses 15, 17
- stats2.txt: cycles=1193, instructions=508, read_hit=100, write_hit=101,
              read_miss=2, write_miss=1, decode_stall=606, mem_stall=75

Core 3 (imem3.asm): Branches with single load at end
- stats3.txt: cycles=1616, instructions=1602, read_miss=1, mem_stall=10

Bus trace shows:
- Cycle 5: Core 2 BusRd for address 0x0F (cache miss)
- Cycles 21-28: Main memory Flush response
- Cycle 31: Core 2 BusRd for address 0x11
- And so on...

================================================================================
END OF SPECIFICATION
================================================================================